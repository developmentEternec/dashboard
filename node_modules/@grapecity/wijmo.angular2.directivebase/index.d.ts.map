{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/*!\n    *\n    * Wijmo Library 5.20211.794\n    * http://wijmo.com/\n    *\n    * Copyright(c) GrapeCity, Inc.  All rights reserved.\n    *\n    * Licensed under the GrapeCity Commercial License.\n    * sales@wijmo.com\n    * wijmo.com/products/wijmo-5/license/\n    *\n    */\n/**\n* {@module wijmo.angular2.directivebase}\n* Basic Wijmo for Angular 2 module containing internal common services and platform options.\n*\n* <b>wijmo.angular2.directivebase</b> is an external TypeScript module that can be imported to your code\n* using its ambient module name. For example:\n*\n* <pre>import * as wjBase from 'wijmo/wijmo.angular2.directivebase';\n* &nbsp;\n* wjBase.WjOptions.asyncBindings = false;</pre>\n*\n*/\n/**\n *\n */\nexport declare var ___keepComment: any;\nimport { Injector, EventEmitter, NgZone } from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport * as ng2 from '@angular/core';\n/**\n * Exposes global options for the Wijmo for Angular 2 interop.\n */\nexport declare class WjOptions {\n    /**\n    * Indicates whether Wijmo components update binding sources of the two-way bound properties asynchronously\n    * or synchronously.\n    *\n    * If this property is set to true (default) then changes to the Wijmo components' properties\n    * with two-way bindings (like WjInputNumber.value) will cause the component to update a binding\n    * source property asynchronously, after the current change detection cycle is completed.\n    * Otherwise, if this property is set to false, the binding source will be updated immediately.\n    * A corresponding property change event (like WjInputNumber.valueChanged) is also triggered\n    * asynchronously or synchronously depending on this property value, after the binding source\n    * was updated.\n    *\n    * This global setting can be changed for specific instances of Wijmo components, by assigning\n    * the component's <b>asyncBindings</b> property with a specific boolean value.\n    *\n    * Transition to asynchronous binding source updates has happened in Wijmo version 350. Before that version,\n    * binding sources were updated immediately after the component's property change. In some cases this\n    * could lead to the <b>ExpressionChangedAfterItHasBeenCheckedError</b> exception in the applications running\n    * Angular in the debug mode. For example, if your component's property value is set to 0.12345, and\n    * you two-way bind it to the <b>value</b> property of the <b>WjInputNumber</b> component with the <b>format</b>\n    * property set to <b>'n2'</b>, the WjInputNumber immediately converts this value to 0.12. This change,\n    * in turn, causes Angular to update your component property (the source of this binding), so that its\n    * value changes from 0.12345 to 0.12. If this source update is performed synchronously then the binding\n    * source property changes its value during the same change detection cycle, which is prohibited by Angular.\n    * If Angular runs in debug mode then it executes a special check after every change detection cycle, which\n    * detects this change and raises the <b>ExpressionChangedAfterItHasBeenCheckedError</b> exception.\n    * Asynchronous binding source updates resolve this problem, because the binding source property\n    * is updated after the current change detection cycle has finished.\n    *\n    * If the <b>ExpressionChangedAfterItHasBeenCheckedError</b> is not an issue for you, and parts of\n    * you application logic are sensible to a moment when binding source update happens, you can change\n    * this functionality by setting the global <b>asyncBindings</b> property to false. This should be\n    * done before the first Wijmo component was instantiated by your application logic, and the best\n    * place to do it is the file where you declare the application's root NgModule. This can be done\n    * with the code like this:\n    * <pre>import * as wjBase from 'wijmo/wijmo.angular2.directivebase';\n    * wjBase.WjOptions.asyncBindings = false;</pre>\n    *\n    * Alternatively, you can change the update mode for the specific component using its own\n    * <b>asyncBindings</b> property. For example:\n    * <pre>&lt;wj-input-number [asyncBindings]=\"false\" [(value)]=\"amount\"&gt;&lt;/wj-input-number&gt;</pre>\n    */\n    static asyncBindings: boolean;\n}\nexport interface IWjMetaBase {\n    selector: string;\n    inputs: string[];\n    outputs: string[];\n    providers: any[];\n}\nexport interface IWjComponentMeta extends IWjMetaBase {\n    template: string;\n}\nexport interface IWjDirectiveMeta extends IWjMetaBase {\n    exportAs: string;\n}\nexport declare type ChangePropertyEvent = {\n    prop: string;\n    evExposed: string;\n    evImpl: string;\n};\nexport declare type EventPropertiesItem = {\n    event: string;\n    eventImpl: string;\n    props?: ChangePropertyEvent[];\n};\nexport declare type EventProperties = EventPropertiesItem[];\nexport interface IWjComponentMetadata {\n    changeEvents?: {\n        [event: string]: string[];\n    };\n    outputs?: string[];\n    siblingId?: string;\n    parentRefProperty?: string;\n}\nexport interface IPendingEvent {\n    event: EventEmitter<any>;\n    args: any;\n}\nexport declare class WjComponentResolvedMetadata {\n    readonly changeEventMap: EventPropertiesItem[];\n    allImplEvents: string[];\n    constructor(rawMeta: IWjComponentMetadata);\n    private resolveChangeEventMap;\n}\nexport declare class WjDirectiveBehavior {\n    static directiveTypeDataProp: string;\n    static directiveResolvedTypeDataProp: string;\n    static BehaviourRefProp: string;\n    static parPropAttr: string;\n    static wjModelPropAttr: string;\n    static initializedEventAttr: string;\n    static isInitializedPropAttr: string;\n    static siblingDirIdAttr: string;\n    static asyncBindingUpdatePropAttr: string;\n    static siblingDirId: number;\n    static wijmoComponentProviderId: string;\n    static ngZone: NgZone;\n    static outsideZoneEvents: {\n        'pointermove': boolean;\n        'pointerover': boolean;\n        'mousemove': boolean;\n        'wheel': boolean;\n        'touchmove': boolean;\n        'pointerenter': boolean;\n        'pointerleave': boolean;\n        'pointerout': boolean;\n        'mouseover': boolean;\n        'mouseenter': boolean;\n        'mouseleave': boolean;\n        'mouseout': boolean;\n    };\n    private static _pathBinding;\n    private _siblingInsertedEH;\n    private _pendingEvents;\n    private _pendingEventsTO;\n    directive: Object;\n    typeData: IWjComponentMetadata;\n    resolvedTypeData: WjComponentResolvedMetadata;\n    elementRef: ng2.ElementRef;\n    injector: ng2.Injector;\n    injectedParent: any;\n    parentBehavior: WjDirectiveBehavior;\n    isInitialized: boolean;\n    isDestroyed: boolean;\n    nz: NgZone;\n    nzRun: (fn: any) => any;\n    static getHostElement(ngHostElRef: ng2.ElementRef, injector?: Injector): HTMLElement;\n    static attach(directive: Object, elementRef: ng2.ElementRef, injector: ng2.Injector, injectedParent: any): WjDirectiveBehavior;\n    static getZone(directive: any): NgZone;\n    constructor(directive: Object, elementRef: ng2.ElementRef, injector: ng2.Injector, injectedParent: any);\n    ngOnInit(): void;\n    ngAfterViewInit(): void;\n    ngOnDestroy(): void;\n    static instantiateTemplate(parent: HTMLElement, viewContainerRef: ng2.ViewContainerRef, templateRef: ng2.TemplateRef<any>, /*domRenderer: ng2.Renderer,*/ useTemplateRoot?: boolean, dataContext?: any): {\n        viewRef: ng2.EmbeddedViewRef<any>;\n        rootElement: Element;\n    };\n    getPropChangeEvent(propName: string): string;\n    private _createEvents;\n    private subscribeToEvents;\n    private addHandlers;\n    private triggerPropChangeEvents;\n    private _setupAsChild;\n    private _isAsyncBinding;\n    private _isChild;\n    private _isParentInitializer;\n    private _isParentReferencer;\n    private _getParentProp;\n    private _getParentReferenceProperty;\n    private _useParentObj;\n    private _parentInCtor;\n    private _initParent;\n    _getSiblingIndex(): number;\n    private _siblingInserted;\n    private _isHostElement;\n    private _triggerEvent;\n    private _triggerPendingEvents;\n    flushPendingEvents(): void;\n    private static evaluatePath;\n    static getBehavior(directive: any): WjDirectiveBehavior;\n}\nexport declare class Ng2Utils {\n    static changeEventImplementSuffix: string;\n    static wjEventImplementSuffix: string;\n    static initEvents(directiveType: any, changeEvents: EventPropertiesItem[]): string[];\n    static getChangeEventNameImplemented(propertyName: any): string;\n    static getChangeEventNameExposed(propertyName: any): string;\n    private static getWjEventNameImplemented;\n    static getWjEventName(ngEventName: string): string;\n    static getBaseType(type: any): any;\n    static getAnnotations(type: any): any[];\n    static getAnnotation(annotations: any[], annotationType: any): any;\n    static getTypeAnnotation(type: any, annotationType: any, own?: boolean): any;\n    static equals(v1: any, v2: any): boolean;\n    static _copy(dst: any, src: any, override?: boolean, includePrivate?: boolean, filter?: (name: string, value: any) => boolean): void;\n}\nexport declare class WjValueAccessor implements ControlValueAccessor {\n    private _writeQnt;\n    private _directive;\n    private _behavior;\n    private _ngModelProp;\n    private _modelValue;\n    private _isSubscribed;\n    private _dirUpdateQnt;\n    private _dirInitEh;\n    private _onChange;\n    private _onTouched;\n    constructor(/*@Inject(Injector) injector: Injector*/ directive: any);\n    writeValue(value: any): void;\n    registerOnChange(fn: (_: any) => void): void;\n    registerOnTouched(fn: () => void): void;\n    setDisabledState(isDisabled: boolean): void;\n    private _updateDirective;\n    private _ensureSubscribed;\n    private _ensureNgModelProp;\n    private _ensureInitEhUnsubscribed;\n    private _isFirstChange;\n    private _dirValChgEh;\n    private _dirLostFocusEh;\n}\nexport declare function WjValueAccessorFactory(/*injector: Injector*/ directive: any): WjValueAccessor;\n"]}